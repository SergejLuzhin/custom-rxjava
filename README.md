# Реализация аналогичной RxJava-библиотеки

## Архитектура реализованной системы

Моя custom-rxjava реализует принципы реактивного программирования, включая асинхронность, потокобезопасность, возможность управления подпиской и потоками выполнения. В основе лежит Observer pattern.

Главные компоненты:

* **Observable<T>** — источник данных, который эмиттит элементы потока и уведомляет подписчиков через onNext, onError и onComplete.
* **Observer<T>** — подписчик, реагирующий на события потока.
* **Disposable** — интерфейс, позволяющий отписаться от потока и прекратить получение данных.
* **Операторы map, filter, flatMap** — позволяют трансформировать и фильтровать поток данных, а также разворачивать вложенные потоки.
* **Schedulers** — механизм управления потоками: позволяет указывать, где выполняется подписка (subscribeOn) и где обрабатываются элементы (observeOn).

Все операции построены на основе цепочек вызовов, что позволяет легко комбинировать преобразования.

## Принципы работы Schedulers, их различия и области применения

Проект включает три реализации интерфейса Scheduler:

1. **IOThreadScheduler** — использует CachedThreadPool. Подходит для задач с высокой задержкой (например, работа с сетью или файлами), где требуется масштабируемость.
2. **ComputationScheduler** — использует FixedThreadPool. Предназначен для CPU-интенсивных задач, где важно контролировать количество потоков.
3. **SingleThreadScheduler** — запускает все задачи в одном потоке. Применим для последовательной обработки, логирования, симуляции UI-потоков.

Методы `subscribeOn(scheduler)` и `observeOn(scheduler)` позволяют определить, где выполняется генерация данных и где — их обработка соответственно.

В демонстрационном тесте `FullFlowTest`:

* `subscribeOn(new IOThreadScheduler())` запускает генерацию значений в пуле потоков;
* `observeOn(new SingleThreadScheduler())` обеспечивает доставку результатов в одном потоке.

## Юнит-тесты

Для проверки корректности реализации были написаны юнит-тесты, покрывающие основные сценарии:

* Проверка работы базовых компонентов (Observer, Observable, Disposable).
* Тесты для операторов map, filter, flatMap с разными наборами данных.
* Проверка правильного распределения задач по Scheduler'ам.
* Тест на отписку от потока и прекращение генерации новых значений.

* Интеграционный тест FullFlowTest, демонстрирующий все элементы в связке: от генерации и трансформации до асинхронного выполнения и отписки.

Тесты запускаются с использованием JUnit через Gradle и позволяют убедиться, что библиотека работает стабильно во всех ключевых аспектах.


## Примеры использования

### Создание Observable

Создаёт поток, эмиттирующий значения и завершающийся:

```java
Observable<Integer> observable = Observable.create(emitter -> {
    for (int i = 1; i <= 5; i++) {
        emitter.onNext(i);
    }
    emitter.onComplete();
});
```

### Подписка на Observable

Реакция на полученные значения, ошибки и завершение потока:

```java
observable.subscribe(new Observer<Integer>() {
    public void onNext(Integer item) {
        System.out.println("Получено: " + item);
    }
    public void onError(Throwable t) {
        System.err.println("Ошибка: " + t.getMessage());
    }
    public void onComplete() {
        System.out.println("Поток завершён.");
    }
});
```

### Оператор filter

В данном примере пропускает только чётные значения:

```java
observable.filter(x -> x % 2 == 0)
          .subscribe(...);
```

### Оператор map

В данном примере преобразует число в строку:

```java
observable.map(x -> "Значение: " + x)
          .subscribe(...);
```

### Оператор flatMap

Каждое значение преобразуется в отдельный Observable, а затем разворачивается:

```java
observable.flatMap(x -> Observable.create(em -> {
    em.onNext("[flatMapped] " + x);
    em.onComplete();
})).subscribe(...);
```

### Управление потоками: subscribeOn и observeOn

Определяет, где выполняется генерация и обработка:

```java
observable.subscribeOn(new IOThreadScheduler()) // генерация — в пуле потоков
          .observeOn(new SingleThreadScheduler()) // обработка — в одном потоке
          .subscribe(...);
```

### Отписка от подписки

Прекращает получение значений из потока:

```java
Disposable disposable = observable.subscribe(...);
Thread.sleep(300);
disposable.dispose();
```

## Заключение

Проект продемонстрировал основы реализации реактивного потока, включая управление подписками, асинхронную обработку и гибкое переключение контекста выполнения. Благодаря модульной архитектуре и тестам удалось обеспечить читаемость и расширяемость системы. Библиотека может служить обучающим инструментом для понимания концепций RxJava и реактивного программирования.
